您想了解 UI 上在同一位置显示的 `gas`、`atc`、`road`、`section` 这些信息,特别是区间限速(`section`)的显示逻辑。<cite/>

## UI 显示位置分析

在 `selfdrive/ui/carrot.cc` 的 `drawHud()` 函数中,这些信息都显示在**左下角的同一个限速显示区域**: [1](#18-0) 

关键代码显示,这个区域会根据不同的速度来源显示不同的标签:
- **CAM**: 摄像头限速(包括区间限速)
- **LIMIT**: 道路限速

## 速度来源的优先级

在 `selfdrive/carrot/carrot_serv.py` 中,`speed_n_sources` 数组定义了所有速度来源及其优先级: [2](#18-1) 

```python
speed_n_sources = [
  (atc_desired, "atc"),
  (atc_desired_next, "atc2"),
  (sdi_speed, "hda" if hda_active else "bump" if self.xSpdType == 22 else "section" if self.xSpdType == 4 else "police" if self.xSpdType == 100 else "waze" if self.xSpdType == 101 else "cam"),
  (limit_speed, "road"),
]
```

关键判断逻辑:
- **`xSpdType == 4`**: 区间限速(`section`)
- **`xSpdType == 22`**: 减速带(`bump`)
- **`xSpdType == 100`**: 警察测速(`police`)
- **`xSpdType == 101`**: Waze 数据(`waze`)
- **其他**: 普通摄像头限速(`cam`)

## 区间限速的完整显示流程

### 1. 数据来源识别

区间限速通过 `xSpdType == 4` 标识,这个值来自导航数据的 SDI 信息。<cite/>当系统检测到区间限速时,会设置相应的标志。<cite/>

### 2. UI 显示逻辑

在 HUD 区域,区间限速的显示遵循以下规则: [3](#18-2) 

```cpp
if (xSpdLimit > 0 && xSignType != 22) {
    disp_speed = (int)(xSpdLimit * ((s->scene.is_metric)?1:KM_TO_MILE) + 0.5);
    limit_color = (blink_timer <= 8) ? COLOR_RED_ALPHA(210) : COLOR_YELLOW_ALPHA(210);
    ui_draw_text(s, dx, dy-45, "CAM", 30, COLOR_WHITE, BOLD);
}
else {
    disp_speed = nRoadLimitSpeed;
    disp_speed = (int)(disp_speed * ((s->scene.is_metric)?1.0:KM_TO_MILE) + 0.5);
    limit_color = (v_ego * 3.6 > disp_speed + 2) ? COLOR_RED_ALPHA(210) : COLOR_WHITE_ALPHA(210);
    ui_draw_text(s, dx, dy - 45, "LIMIT", 30, COLOR_WHITE, BOLD);
}
```

**显示特点**:
- 区间限速时显示 "CAM" 标签(因为 `xSpdType == 4` 被归类为摄像头类型)
- 背景颜色在红色和黄色之间闪烁,提醒驾驶员注意
- 显示的速度值是 `xSpdLimit`(区间限速的速度)

### 3. 速度控制逻辑

在速度控制中,区间限速会影响车辆的目标速度: [4](#18-3) 

```python
if CS.vEgo < 0.1 or desired_speed > 150 or source in ["cam", "section", "police"] or CS.brakePressed or road_speed_limit_changed:
    self.gas_override_speed = 0
```

这意味着当速度来源是 `section`(区间限速)时,系统会重置油门覆盖速度,确保车辆遵守区间限速。<cite/>

## 同一位置显示不同信息的原因

这个设计是为了在有限的 UI 空间内显示最重要的速度限制信息:<cite/>

1. **优先级最高**: `gas` - 油门覆盖速度(用户主动加速)
2. **优先级次高**: `atc` - 自动转弯控制速度
3. **优先级中等**: `section`/`cam`/`police` - 各种摄像头限速
4. **优先级最低**: `road` - 道路限速

系统通过 `min(speed_n_sources, key=lambda x: x[0])` 选择最小的速度值作为目标速度,并在 UI 上显示对应的来源标签。<cite/>

## Notes

区间限速(`section`)在 UI 上显示为 "CAM",这可能会让用户误以为是普通的摄像头限速。<cite/>但在速度控制逻辑中,系统会正确识别并处理区间限速,确保在整个区间内保持限速。<cite/>

如果您想区分区间限速和普通摄像头限速,可以修改 `drawHud()` 函数,根据 `xSpdType == 4` 显示 "SECTION" 而不是 "CAM"。<cite/>

### Citations

**File:** selfdrive/ui/carrot.cc (L2482-2502)
```text
        //if (active_carrot >= 2 || nGoPosDist > 0) {
        if (true) {
            dx = bx + 75;
            dy = by + 175;
            int disp_speed = 0;
            NVGcolor limit_color = COLOR_GREEN_ALPHA(210);
            if (xSpdLimit > 0 && xSignType != 22) {
                disp_speed = (int)(xSpdLimit * ((s->scene.is_metric)?1:KM_TO_MILE) + 0.5);
                limit_color = (blink_timer <= 8) ? COLOR_RED_ALPHA(210) : COLOR_YELLOW_ALPHA(210);
                ui_draw_text(s, dx, dy-45, "CAM", 30, COLOR_WHITE, BOLD);
            }
            else {
                disp_speed = nRoadLimitSpeed;
		            disp_speed = (int)(disp_speed * ((s->scene.is_metric)?1.0:KM_TO_MILE) + 0.5);
                limit_color = (v_ego * 3.6 > disp_speed + 2) ? COLOR_RED_ALPHA(210) : COLOR_WHITE_ALPHA(210);
                ui_draw_text(s, dx, dy - 45, "LIMIT", 30, COLOR_WHITE, BOLD);
            }

            ui_fill_rect(s->vg, { dx - 55, dy - 38, 110, 48 }, limit_color, 15, 2);
            ui_draw_text(s, dx, dy, QString::number(disp_speed).toStdString().c_str(), 40, COLOR_WHITE, BOLD);
        }
```

**File:** selfdrive/carrot/carrot_serv.py (L969-974)
```python
    speed_n_sources = [
      (atc_desired, "atc"),
      (atc_desired_next, "atc2"),
      (sdi_speed, "hda" if hda_active else "bump" if self.xSpdType == 22 else "section" if self.xSpdType == 4 else "police" if self.xSpdType == 100 else "waze" if self.xSpdType == 101 else "cam"),
      (limit_speed, "road"),
    ]
```

**File:** selfdrive/carrot/carrot_serv.py (L992-992)
```python
      if CS.vEgo < 0.1 or desired_speed > 150 or source in ["cam", "section", "police"] or CS.brakePressed or road_speed_limit_changed:
```

## CarrotPilot速度来源显示与区间限速处理流程
本代码图展示了CarrotPilot中速度来源(gas, atc, road, section)的完整处理流程，从数据源优先级处理到UI显示。重点展示了区间限速(section)通过xSpdType==4标识的检测逻辑[2a]，以及所有速度来源如何在同一HUD位置显示[4b]。
### 1. 速度来源优先级处理
在carrot_serv.py中处理各种速度来源(gas, atc, road, section)并按优先级选择目标速度
### 1a. 速度来源数组定义 (`carrot_serv.py:969`)
定义所有速度来源及其标签，包括section(区间限速)通过xSpdType==4标识
```text
speed_n_sources = [
      (atc_desired, "atc"),
      (atc_desired_next, "atc2"),
      (sdi_speed, "hda" if hda_active else "bump" if self.xSpdType == 22 else "section" if self.xSpdType == 4 else "police" if self.xSpdType == 100 else "waze" if self.xSpdType == 101 else "cam"),
      (limit_speed, "road"),
    ]
```
### 1b. 选择最小速度作为目标 (`carrot_serv.py:986`)
从所有速度来源中选择最小值作为最终目标速度，确保安全限制
```text
desired_speed, source = min(speed_n_sources, key=lambda x: x[0])
```
### 1c. 油门覆盖逻辑 (`carrot_serv.py:1000`)
当驾驶员踩油门时，gas来源覆盖其他所有速度限制
```text
if desired_speed < self.gas_override_speed:
        source = "gas"
        desired_speed = self.gas_override_speed
```
### 2. 区间限速检测与处理
系统如何检测xSpdType==4的区间限速并设置相应的active_carrot状态
### 2a. 区间限速状态设置 (`carrot_serv.py:929`)
检测到xSpdType==4时，设置active_carrot=4并使用区间限速值
```text
if self.xSpdType == 4 or (self.xSpdType in [100, 101] and self.xSpdDist <= 0):
        sdi_speed = self.xSpdLimit
        self.active_carrot = 4
```
### 2b. 区间限速时重置油门覆盖 (`carrot_serv.py:992`)
当速度来源为section时，强制重置油门覆盖速度以确保遵守限速
```text
if CS.vEgo < 0.1 or desired_speed > 150 or source in ["cam", "section", "police"] or CS.brakePressed or road_speed_limit_changed:
        self.gas_override_speed = 0
```
### 3. 消息传递与数据封装
速度信息如何通过carrotMan消息从服务传递到UI层
### 3a. 封装速度信息到消息 (`carrot_serv.py:1058`)
将目标速度和来源标签封装到carrotMan消息中
```text
msg.carrotMan.desiredSpeed = int(desired_speed)
    msg.carrotMan.desiredSource = source
```
### 3b. 封装限速详细信息 (`carrot_serv.py:1047`)
将限速类型、限速值和距离信息封装到消息中供UI使用
```text
msg.carrotMan.xSpdType = int(self.xSpdType)
    msg.carrotMan.xSpdLimit = int(self.xSpdLimit)
    msg.carrotMan.xSpdDist = int(self.xSpdDist)
```
### 3c. 发送消息到UI (`carrot_serv.py:1079`)
通过PubSub系统发送carrotMan消息到UI层
```text
pm.send('carrotMan', msg)
```
### 4. UI显示逻辑
UI如何接收并显示速度来源信息，包括gas、atc、road、section在同一位置的处理
### 4a. 接收速度来源信息 (`carrot.cc:2012`)
从carrotMan消息中提取目标速度和来源标签
```text
apply_speed = carrot_man.getDesiredSpeed();
            apply_source = QString::fromStdString(carrot_man.getDesiredSource());
            if (apply_speed >= v_cruise) apply_source = "";
```
### 4b. 显示速度来源标签 (`carrot.cc:2371`)
在同一HUD位置显示速度值和来源标签(gas/atc/road/section)
```text
if (apply_source.length()) {
            sprintf(apply_speed_str, "%d", (int)((s->scene.is_metric)?apply_speed:apply_speed * KM_TO_MILE + 0.5));
            textColor = COLOR_OCHRE;
            ui_draw_text(s, apply_x, apply_y, apply_speed_str, 50, textColor, BOLD, 1.0, 5.0, COLOR_BLACK, COLOR_BLACK);
            ui_draw_text(s, apply_x, apply_y - 50, apply_source.toStdString().c_str(), 30, textColor, BOLD, 1.0, 5.0, COLOR_BLACK, COLOR_BLACK);
        }
```
### 4c. 区间限速特殊显示 (`carrot.cc:2488`)
区间限速显示为"CAM"标签，背景红黄闪烁提醒，与普通限速的"LIMIT"标签区分
```text
if (xSpdLimit > 0 && xSignType != 22) {
                disp_speed = (int)(xSpdLimit * ((s->scene.is_metric)?1:KM_TO_MILE) + 0.5);
                limit_color = (blink_timer <= 8) ? COLOR_RED_ALPHA(210) : COLOR_YELLOW_ALPHA(210);
                ui_draw_text(s, dx, dy-45, "CAM", 30, COLOR_WHITE, BOLD);
            }
```