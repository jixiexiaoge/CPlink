# CarrotMan Android应用逆向分析报告

## 1. 应用概述

CarrotMan是一个Android应用程序，用于与Comma.ai设备（Carrot设备）进行实时通信，接收导航和车辆信息，并通过蓝牙低功耗（BLE）将数据传输到HUD显示设备。该应用基于Kotlin和Java开发，采用现代Android架构模式。

**包名**: `com.ajouatom.carrotman`

## 2. UDP端口7705通信协议详细分析

### 2.1 接收的JSON数据结构（BroadcastData）

应用在UDP端口7705监听来自Carrot设备的广播数据，接收的JSON包含以下完整字段：

```java
// BroadcastData.java - 接收的JSON数据结构
@JsonProperty("ip") private final String ip;                    // Carrot设备IP地址
@JsonProperty("port") private final int port;                  // 动态UDP发送端口
@JsonProperty("IsOnroad") private final boolean isOnRoad;     // 是否在路上
@JsonProperty("CarrotRouteActive") private final boolean carrotRouteActive; // 路线是否激活
@JsonProperty("active") private final boolean active;         // 设备是否活跃
@JsonProperty("xState") private final int xState;            // 状态码（3或5表示相机激活）
@JsonProperty("trafficState") private final int trafficState; // 交通状态
@JsonProperty("v_ego_kph") private final int vEgoKph;         // 车辆当前速度(km/h)
@JsonProperty("v_cruise_kph") private final int vCruiseKph;   // 巡航速度(km/h)
@JsonProperty("tbt_dist") private final int tbtDist;          // 转向距离(米)
@JsonProperty("sdi_dist") private final int sdiDist;         // SDI距离(米)
@JsonProperty("log_carrot") private final String logCarrot;  // 日志信息
@JsonProperty("Carrot2") private final String carrot2;       // Carrot2设备标识
```

### 2.2 字段详细说明

| 字段名 | 数据类型 | 含义 | 示例值 |
|--------|----------|------|--------|
| `ip` | String | Carrot设备IP地址 | "192.168.1.100" |
| `port` | int | 动态UDP发送端口 | 8755 |
| `IsOnroad` | boolean | 车辆是否在路上行驶 | true |
| `CarrotRouteActive` | boolean | 导航路线是否激活 | true |
| `active` | boolean | 设备是否处于活跃状态 | true |
| `xState` | int | 系统状态码 | 3, 5 (相机激活) |
| `trafficState` | int | 交通状态标识 | 1 |
| `v_ego_kph` | int | 车辆当前速度(km/h) | 60 |
| `v_cruise_kph` | int | 设定的巡航速度(km/h) | 80 |
| `tbt_dist` | int | 到下一个转向点的距离(米) | 500 |
| `sdi_dist` | int | SDI(速度限制信息)距离(米) | 1000 |
| `log_carrot` | String | 设备日志信息 | "系统运行正常" |
| `Carrot2` | String | Carrot2设备标识符 | "CARROT2_DEVICE" |

### 2.3 相机状态判断逻辑

```java
// 相机激活条件判断
boolean cameraState = data.getActive() && (data.getXState() == 3 || data.getXState() == 5);
```

**状态码说明**:
- `xState = 3`: 相机激活状态1
- `xState = 5`: 相机激活状态2
- 只有当`active=true`且`xState`为3或5时，相机才会启动

## 3. 数据发送机制深度分析

### 3.1 发送频率控制机制

应用使用**阻塞队列**自然控制发送频率，这是其核心设计亮点：

```java
// CarrotServicesendCarrotCommand1.java - 发送频率控制
while (CoroutineScopeKt.isActive($this$withContext)) {
    CarrotCommand cmd = (CarrotCommand) CarrotService.carrotCommandQueue.take(); // 阻塞等待
    Log.d("CarrotService", "sendCarrotCommand: hash:" + cmd.hashCode());
    // 处理命令...
    postCarrotData(cmd, continuation);
}
```

**关键机制**:
1. **阻塞等待**: `queue.take()`方法会阻塞协程直到有数据可用
2. **自然节流**: 没有数据时协程挂起，有数据时立即处理
3. **无忙等待**: 避免了CPU空转，节省电量

### 3.2 UDP和TCP使用场景

#### UDP发送（动态端口）
```java
// CarrotServicepostCarrotData2.java - UDP发送实现
DatagramSocket datagramSocket = new DatagramSocket();
socket.setSoTimeout(5000);  // 5秒超时
byte[] bytes = json.getBytes(Charsets.UTF_8);
socket.send(new DatagramPacket(bytes, length, new InetSocketAddress(ip, port)));
```

**UDP发送数据类型**:
- 车辆状态信息（OpakrSinf）
- 路线信息（OpakrRoute）
- 导航数据（OpakrRgdata）
- 命令数据（CarrotCommand）

#### TCP发送（固定端口7709）
```java
// CarrotServicesendVertx1.java - TCP发送实现
Socket socket = new Socket(ip, 7709);  // 固定端口7709
socket.setSoTimeout(5000);
DataOutputStream stream = new DataOutputStream(socket.getOutputStream());
stream.writeInt(vrtxs.size() * 8);  // 写入顶点数量
for (OpakrVertex vertex : vrtxs) {
    stream.writeFloat((float) vertex.getX());
    stream.writeFloat((float) vertex.getY());
}
```

**TCP发送数据类型**:
- 路径顶点坐标（OpakrVertex列表）
- 二进制格式传输，每个顶点8字节（2个float）

### 3.3 发送端口动态配置机制

```java
// CarrotService.java - 动态端口配置
LiveData.INSTANCE.getCarrotBroadcastData().observeForever(new Observer() {
    public final void invoke(BroadcastData it) {
        CarrotService.port = it != null ? Integer.valueOf(it.getPort()) : null;
        CarrotService.ip = it != null ? it.getIp() : null;
    }
});
```

**配置流程**:
1. 监听UDP广播（端口7705）
2. 解析BroadcastData中的`ip`和`port`字段
3. 存储到静态变量供后续发送使用
4. 发送时使用动态获取的IP和端口

## 4. 队列与数据流管理详细分析

### 4.1 五个LinkedBlockingQueue详细分析

```java
// CarrotService.java - 队列定义
private static final LinkedBlockingQueue<OpakrSinf> sinfQueue = new LinkedBlockingQueue<>();
private static final LinkedBlockingQueue<OpakrRoute> routeQueue = new LinkedBlockingQueue<>();
private static final LinkedBlockingQueue<List<OpakrVertex>> vrtxQueue = new LinkedBlockingQueue<>();
private static final LinkedBlockingQueue<OpakrRgdata> rgdataQueue = new LinkedBlockingQueue<>();
private static final LinkedBlockingQueue<CarrotCommand> carrotCommandQueue = new LinkedBlockingQueue<>();
```

| 队列名 | 数据类型 | 用途 | 容量 |
|--------|----------|------|------|
| `sinfQueue` | OpakrSinf | 车辆状态信息 | 无界 |
| `routeQueue` | OpakrRoute | 路线信息 | 无界 |
| `vrtxQueue` | List<OpakrVertex> | 路径顶点坐标 | 无界 |
| `rgdataQueue` | OpakrRgdata | 导航引导数据 | 无界 |
| `carrotCommandQueue` | CarrotCommand | 命令数据 | 无界 |

### 4.2 Producer-Consumer模式实现

#### 生产者（LiveData观察者）
```java
// CarrotService.java - 生产者实现
LiveData.INSTANCE.getOpakrSinf().observeForever(new Observer() {
    public final void invoke(OpakrSinf it) {
        CarrotService.sinfQueue.put(it);  // 阻塞式插入
    }
});
```

#### 消费者（协程处理）
```java
// CarrotServicesendCarrotCommand1.java - 消费者实现
while (CoroutineScopeKt.isActive($this$withContext)) {
    CarrotCommand cmd = (CarrotCommand) carrotCommandQueue.take();  // 阻塞式取出
    // 处理数据...
    postCarrotData(cmd, continuation);
}
```

### 4.3 有界队列vs无界队列的选择

#### 无界数据队列（5个主要队列）
- **优势**: 不会丢失数据，适合实时性要求高的场景
- **风险**: 内存可能无限增长
- **缓解**: 通过阻塞机制自然控制流量

#### 有界日志队列（mainLog）
```java
// LiveData.java - 有界日志队列
private static final LinkedBlockingQueue<String> mainLog = new LinkedBlockingQueue<>(4096);
```

**滚动队列机制**:
```java
// ExtensionKt.java - 滚动队列实现
public static final <E> void push(LinkedBlockingQueue<E> queue, E item) {
    while (!queue.offer(item)) {  // 非阻塞插入
        queue.poll();              // 队列满时移除最老项
    }
}
```

## 5. 自动重连机制详细分析

### 5.1 BLE设备重连策略

```java
// HudService.java - BLE重连机制
private final void startBleRetryConnection() {
    this.bleRetryCount = 0;
    this.bleRetrying = true;
    this.bleRetryHandler.post(this.retryRunnable);
}

// 重连逻辑
if (getBleRetrying()) {
    bleRetryCount++;
    if (bleRetryCount > 10) {  // 最多重试10次
        Log.d("HudService", "Failed to connect to BLE device.");
        stopSelf();
    }
    if (!bleManager.isConnected()) {
        bleManager.startScan();  // 重新扫描
    }
    getBleRetryHandler().postDelayed(this, getBleRetryInterval()); // 10秒后重试
}
```

**重连参数**:
- 重试间隔: 10秒
- 最大重试次数: 10次
- 总重连时间: 100秒

### 5.2 UDP广播监听持续性

```java
// CarrotServicereceiveBroadcast1.java - UDP广播监听
private final Job receiveBroadcast() {
    return BuildersKt.launch(ioScope, new Coroutine() {
        // 持续监听UDP广播
        while (true) {
            // 接收广播数据
            // 解析JSON
            // 更新LiveData
        }
    });
}
```

**监听特点**:
- 持续运行，不会停止
- 使用协程在IO线程执行
- 自动解析JSON并更新状态

### 5.3 断开连接后的清理流程

```java
// CarrotService.java - 断开连接清理
public final void disconnected() {
    // 清空所有队列
    sinfQueue.clear();
    routeQueue.clear();
    vrtxQueue.clear();
    rgdataQueue.clear();
    carrotCommandQueue.clear();
    
    // 重置计数器
    carrotCounter = 0;
    
    // 停止GPS更新
    gps.stopLocationUpdates();
    
    // 清除广播数据
    LiveData.INSTANCE.getCarrotBroadcastData().postValue(null);
}
```

## 6. 临时数据销毁策略

### 6.1 disconnected()方法完整分析

```java
public final void disconnected() {
    // 1. 清空所有数据队列
    sinfQueue.clear();
    routeQueue.clear();
    vrtxQueue.clear();
    rgdataQueue.clear();
    carrotCommandQueue.clear();
    
    // 2. 重置全局计数器
    carrotCounter = 0;
    
    // 3. 停止GPS定位服务
    GpsService gpsService = gps;
    if (gpsService != null) {
        gpsService.stopLocationUpdates();
    }
    
    // 4. 清除设备连接状态
    LiveData.INSTANCE.getCarrotBroadcastData().postValue(null);
}
```

### 6.2 资源释放流程

**BLE资源释放**:
```java
// HudService.java - BLE资源释放
@Override
public void onDestroy() {
    // 释放WakeLock
    wakeLock.release();
    
    // 断开BLE连接
    bleManager.disconnect();
    
    // 停止重连机制
    stopBleRetryConnection();
    
    // 移除观察者
    LiveData.INSTANCE.getCarrotBroadcastData().removeObserver(carrotBroadcastObserver);
    LiveData.INSTANCE.getOpakrRgdata().removeObserver(opakrRgdataObserver);
}
```

**Socket资源释放**:
```java
// CarrotServicepostCarrotData2.java - Socket资源管理
try {
    DatagramSocket socket = new DatagramSocket();
    // 使用socket...
} finally {
    CloseableKt.closeFinally(socket, null);  // 确保资源释放
}
```

## 7. 数据堵塞防护机制

### 7.1 有界日志队列（4096）的滚动机制

```java
// LiveData.java - 有界日志队列
private static final LinkedBlockingQueue<String> mainLog = new LinkedBlockingQueue<>(4096);
```

**滚动实现**:
```java
// ExtensionKt.java - 滚动队列实现
public static final <E> void push(LinkedBlockingQueue<E> queue, E item) {
    while (!queue.offer(item)) {  // 尝试非阻塞插入
        queue.poll();              // 队列满时移除最老项
    }
}
```

**防护效果**:
- 队列永远不会阻塞
- 自动丢弃最旧的日志条目
- 保持最新的4096条日志

### 7.2 无界数据队列的流量控制

**自然流量控制机制**:
```java
// 通过阻塞队列的take()方法实现自然流量控制
while (CoroutineScopeKt.isActive($this$withContext)) {
    CarrotCommand cmd = (CarrotCommand) carrotCommandQueue.take();  // 阻塞等待
    // 处理数据...
}
```

**控制原理**:
1. 没有数据时协程挂起
2. 有数据时立即处理
3. 处理完一个再取下一个
4. 自然形成流量控制

### 7.3 超时处理（5秒）

```java
// CarrotServicepostCarrotData2.java - 超时处理
try {
    DatagramSocket socket = new DatagramSocket();
    socket.setSoTimeout(5000);  // 5秒超时
    socket.send(packet);
} catch (SocketTimeoutException e) {
    Log.e("CarrotService", "postCarrotData: timeout", e);
    ExtensionKt.push(LiveData.INSTANCE.getMainLog(), "postCarrotData: timeout " + e.getMessage());
} catch (Exception e) {
    Log.e("CarrotService", "postCarrotData: error", e);
    ExtensionKt.push(LiveData.INSTANCE.getMainLog(), "postCarrotData: error " + e.getMessage());
}
```

## 8. 发送数据结构（CarrotData）详细分析

### 8.1 发送到Carrot设备的JSON字段

```java
// CarrotData.java - 发送数据结构（40+字段）
@JsonProperty("carrotIndex") private Integer carrotIndex;     // 数据索引
@JsonProperty("epochTime") private Long epochTime;           // 时间戳
@JsonProperty("timezone") private String timezone;          // 时区
@JsonProperty("carrotCmd") private String carrotCmd;        // 命令类型
@JsonProperty("carrotArg") private String carrotArg;        // 命令参数

// GPS数据
@JsonProperty("latitude") private Double latitude;           // 纬度
@JsonProperty("longitude") private Double longitude;        // 经度
@JsonProperty("heading") private Float heading;             // 方向角
@JsonProperty("gps_speed") private Float gps_speed;        // GPS速度
@JsonProperty("accuracy") private Float accuracy;          // 精度

// 导航数据
@JsonProperty("nTBTDist") private Integer nTBTDist;         // 转向距离
@JsonProperty("nTBTTurnType") private Integer nTBTTurnType; // 转向类型
@JsonProperty("szTBTMainText") private String szTBTMainText; // 主要文本
@JsonProperty("nSdiType") private Integer nSdiType;         // SDI类型
@JsonProperty("nSdiDist") private Integer nSdiDist;         // SDI距离
@JsonProperty("nSdiSpeedLimit") private Integer nSdiSpeedLimit; // 速度限制

// 目标信息
@JsonProperty("szGoalName") private String szGoalName;      // 目标名称
@JsonProperty("goalPosX") private Integer goalPosX;         // 目标X坐标
@JsonProperty("goalPosY") private Integer goalPosY;         // 目标Y坐标
@JsonProperty("nGoPosDist") private Integer nGoPosDist;     // 距离目标距离
@JsonProperty("nGoPosTime") private Integer nGoPosTime;     // 预计到达时间

// 道路信息
@JsonProperty("szPosRoadName") private String szPosRoadName; // 当前道路名称
@JsonProperty("roadcate") private Integer roadcate;         // 道路类别
@JsonProperty("nLaneCount") private Integer nLaneCount;     // 车道数量
@JsonProperty("nRoadLimitSpeed") private Integer nRoadLimitSpeed; // 道路限速

// 位置信息
@JsonProperty("nPosAngle") private Integer nPosAngle;        // 位置角度
@JsonProperty("nPosSpeed") private Integer nPosSpeed;       // 位置速度
@JsonProperty("vpPosPointLat") private String vpPosPointLat; // 位置点纬度
@JsonProperty("vpPosPointLon") private String vpPosPointLon; // 位置点经度

// SDI详细信息
@JsonProperty("nSdiSection") private Integer nSdiSection;    // SDI路段
@JsonProperty("nSdiBlockType") private Integer nSdiBlockType; // SDI阻塞类型
@JsonProperty("nSdiBlockSpeed") private Integer nSdiBlockSpeed; // SDI阻塞速度
@JsonProperty("nSdiBlockDist") private Integer nSdiBlockDist; // SDI阻塞距离

// SDI Plus信息
@JsonProperty("nSdiPlusType") private Integer nSdiPlusType;  // SDI Plus类型
@JsonProperty("nSdiPlusDist") private Integer nSdiPlusDist;  // SDI Plus距离
@JsonProperty("nSdiPlusSpeedLimit") private Integer nSdiPlusSpeedLimit; // SDI Plus限速
@JsonProperty("nSdiPlusBlockType") private Integer nSdiPlusBlockType; // SDI Plus阻塞类型
@JsonProperty("nSdiPlusBlockSpeed") private Integer nSdiPlusBlockSpeed; // SDI Plus阻塞速度
@JsonProperty("nSdiPlusBlockDist") private Integer nSdiPlusBlockDist; // SDI Plus阻塞距离

// TBT详细信息
@JsonProperty("nTBTDistNext") private Integer nTBTDistNext;  // 下一个转向距离
@JsonProperty("nTBTTurnTypeNext") private Integer nTBTTurnTypeNext; // 下一个转向类型
@JsonProperty("nTBTNextRoadWidth") private Integer nTBTNextRoadWidth; // 下一个道路宽度
@JsonProperty("szTBTMainTextNext") private String szTBTMainTextNext; // 下一个主要文本

// 方向信息
@JsonProperty("szNearDirName") private String szNearDirName; // 近处方向名称
@JsonProperty("szFarDirName") private String szFarDirName;   // 远处方向名称
```

### 8.2 数据增强机制

```java
// CarrotServicepostCarrotData2.java - 发送前数据增强
carrotData.setCarrotIndex(CarrotService.INSTANCE.getCarrotCounter());  // 设置索引
carrotData.setEpochTime(Instant.now().getEpochSecond());               // 设置时间戳
carrotData.setTimezone(TimeZone.getDefault().getID());                // 设置时区
```

## 9. 关键设计模式分析

### 9.1 观察者模式（LiveData）

```java
// 全局状态管理
LiveData.INSTANCE.getCarrotBroadcastData().observeForever(observer);
LiveData.INSTANCE.getOpakrSinf().observeForever(observer);
LiveData.INSTANCE.getOpakrRoute().observeForever(observer);
```

### 9.2 生产者-消费者模式

```java
// 生产者：LiveData观察者
LiveData.INSTANCE.getOpakrSinf().observeForever(new Observer() {
    public final void invoke(OpakrSinf it) {
        CarrotService.sinfQueue.put(it);  // 生产数据
    }
});

// 消费者：协程处理
while (CoroutineScopeKt.isActive($this$withContext)) {
    OpakrSinf data = (OpakrSinf) sinfQueue.take();  // 消费数据
    postCarrotData(data, continuation);
}
```

### 9.3 单例模式

```java
// 全局单例
public static final LiveData INSTANCE = new LiveData();
public static final CarrotService INSTANCE = new CarrotService();
public static final JsonUtils INSTANCE = new JsonUtils();
```

## 10. 性能优化技巧总结

### 10.1 协程使用优化

```java
// IO密集型操作使用IO dispatcher
private CoroutineScope ioScope = CoroutineScopeKt.CoroutineScope(Dispatchers.getIO());

// UI操作使用Main dispatcher
private CoroutineScope mainScope = CoroutineScopeKt.CoroutineScope(Dispatchers.getMain());
```

### 10.2 资源管理优化

```java
// 自动资源释放
try {
    DatagramSocket socket = new DatagramSocket();
    // 使用socket...
} finally {
    CloseableKt.closeFinally(socket, null);
}
```

### 10.3 内存管理优化

```java
// 有界队列防止内存溢出
LinkedBlockingQueue<String> mainLog = new LinkedBlockingQueue<>(4096);

// 滚动队列机制
while (!queue.offer(item)) {
    queue.poll();  // 移除最老项
}
```

## 11. 数据流向图

```
Carrot设备 (UDP广播 :7705)
    │
    ↓ 解析BroadcastData
CarrotService.receiveBroadcast()
    │
    ├─→ 提取IP和端口 → 存储到静态变量
    ├─→ 更新连接状态 → LiveData.carrotDeviceConnected
    └─→ 启动GPS服务 → GpsService.requestLocationUpdates()
            │
            ↓
导航数据生成 (TMap/其他源)
    │
    ↓
LiveData.opakrXxxx.postValue()
    │
    ↓
CarrotService观察器
    │
    ↓
放入LinkedBlockingQueue
    │
    ↓
Consumer协程.take() (阻塞等待)
    │
    ↓
postCarrotData()
    │
    ├─→ 添加元数据 (索引、时间戳、时区)
    ├─→ JSON序列化 (JsonUtils.toJsonString)
    └─→ UDP发送到Carrot设备 (动态端口)
```

## 12. 总结

CarrotMan应用展现了Android平台上高性能实时通信应用的最佳实践：

**核心优势**:
1. **高效的数据流管理**: 使用阻塞队列和协程实现自然流量控制
2. **灵活的网络协议**: 同时支持UDP和TCP，动态端口配置
3. **完善的错误处理**: 超时、重连、异常捕获机制
4. **模块化架构**: 清晰的服务分层和职责分离
5. **实时性能**: 相机检测、语音识别、导航数据实时处理

**技术亮点**:
- LinkedBlockingQueue实现自然流量控制
- 动态UDP端口配置
- 滚动日志队列防止内存溢出
- BLE自动重连机制
- 协程并发优化

**应用场景**:
- Comma.ai设备远程监控和控制
- 实时导航数据可视化
- HUD抬头显示集成
- 车辆状态监测

该应用适合作为类似项目的参考架构，展示了现代Android开发中网络通信、数据管理和性能优化的最佳实践。

根据代码分析，以下是 CarrotMan 应用中各个代码文件的功能说明表：

| 文件名 | 功能描述 |
|--------|----------|
| **CarrotService.java** | 核心服务类，负责与 Carrot 设备通信，管理数据队列，接收广播数据，发送导航、路线、顶点等各类数据到 Carrot 设备，并初始化 GPS 服务。 [1](#7-0)  |
| **CarrotServicepostCarrotData2.java** | 协程任务类，通过 UDP 协议将 CarrotData 数据发送到 Carrot 设备，包含时间戳、时区等信息的设置和网络超时处理。 [2](#7-1)  |
| **BroadcastData.java** | 数据传输对象（DTO），存储从 Carrot 设备接收的广播数据，包括 IP 地址、端口号、车辆状态（速度、巡航状态）、导航距离、摄像头状态等信息。 [3](#7-2)  |
| **CarrotData.java** | 数据传输对象（DTO），包含完整的导航和 GPS 数据，如经纬度、速度、航向、道路限速、转弯指示（TBT）、安全驾驶信息（SDI）、目的地信息等。 [4](#7-3)  |
| **Detector.java** | 使用 TensorFlow Lite 实现的目标检测类，通过摄像头进行实时物体识别，应用 NMS（非极大值抑制）算法过滤检测结果，支持 GPU 加速。 [5](#7-4)  |
| **MainActivity.java** | 应用主界面 Activity，管理相机预览、语音识别、权限请求、UI 交互，启动前台服务（HudService），处理用户设置和日志显示。 [6](#7-5)  |
| **HudService.java** | 前台服务，通过 BLE（蓝颈低功耗蓝牙）与 HUD 抬头显示设备通信，发送导航和车辆信息到外部显示设备，管理连接重试机制和 WakeLock。 [7](#7-6)  |
| **UpdateService.java** | 应用更新服务，检查远程服务器上的新版本，下载并安装 APK 更新文件，使用 DownloadManager 管理下载过程。 [8](#7-7)  |
| **AndroidManifest.xml** | Android 应用配置文件，声明权限（相机、定位、蓝牙、网络等）、服务（HudService）、Activity、ContentProvider 和其他应用组件。 [9](#7-8)  |
| **CarrotServicesendVertx1.java** | 协程任务类，通过 TCP Socket 将路线顶点（Vertex）数据发送到 Carrot 设备的 7709 端口，用于路径导航显示。 [10](#7-9)  |
| **ExtensionKt.java** | Kotlin 扩展函数工具类，提供数据包转换、队列推送、颜色资源获取等通用功能，简化代码编写。 [11](#7-10)  |
| **LiveData.java** | 全局 LiveData 管理类，集中管理应用中的各种实时数据流（广播数据、设备连接状态、导航数据、配置选项等），实现组件间的响应式通信。 [12](#7-11)  |
| **Options.java** | ZMQ（ZeroMQ）消息队列库的配置选项类，用于设置 Socket 参数、加密、认证等，属于第三方库 JeroMQ 的一部分。 [13](#7-12)  |

**注释：**
- CarrotMan 应用是一个导航辅助应用，与 Carrot 导航设备和 HUD 抬头显示设备配合使用
- 主要功能包括接收导航数据、摄像头物体检测、语音识别、蓝牙通信等
- Options.java 是 ZeroMQ 库文件，不是应用自身开发的代码

### Citations

**File:** app/src/main/java/com/ajouatom/carrotman/service/CarrotService.java (L33-81)
```java
public final class CarrotService {
    private static final int BUF_SIZE = 1024;
    private static final int PORT = 7705;
    private static final int TIMEOUT = 5000;
    private static int cameraStateCount;
    private static int carrotCounter;
    private static boolean enableRoute;
    private static GpsService gps;
    private static String ip;
    private static Integer port;
    public static final CarrotService INSTANCE = new CarrotService();
    private static CoroutineScope mainScope = CoroutineScopeKt.CoroutineScope(Dispatchers.getMain());
    private static CoroutineScope ioScope = CoroutineScopeKt.CoroutineScope(Dispatchers.getIO());
    private static final LinkedBlockingQueue<OpakrSinf> sinfQueue = new LinkedBlockingQueue<>();
    private static final LinkedBlockingQueue<OpakrRoute> routeQueue = new LinkedBlockingQueue<>();
    private static final LinkedBlockingQueue<List<OpakrVertex>> vrtxQueue = new LinkedBlockingQueue<>();
    private static final LinkedBlockingQueue<OpakrRgdata> rgdataQueue = new LinkedBlockingQueue<>();
    private static final LinkedBlockingQueue<CarrotCommand> carrotCommandQueue = new LinkedBlockingQueue<>();

    private CarrotService() {
    }

    static {
        Log.d("CarrotService", "init");
        INSTANCE.receiveBroadcast();
        INSTANCE.sendCarrotCommand();
        INSTANCE.sendRgdata();
        INSTANCE.sendVertx();
        INSTANCE.sendRoute();
        BuildersKt__Builders_commonKt.launch$default(mainScope, null, null, new fun1(null), 3, null);
    }

    public final int getCarrotCounter() {
        int i = carrotCounter;
        carrotCounter = i + 1;
        return i;
    }

    public final void init(Context context) {
        Intrinsics.checkNotNullParameter(context, "context");
        Log.d("CarrotService", "init()");
        gps = new GpsService(context);
        GpsService gpsService = gps;
        if (gpsService == null) {
            Intrinsics.throwUninitializedPropertyAccessException("gps");
            gpsService = null;
        }
        gpsService.initializeGPS();
    }
```

**File:** app/src/main/java/com/ajouatom/carrotman/service/CarrotServicepostCarrotData2.java (L30-92)
```java
final class CarrotServicepostCarrotData2 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object> {
    final CarrotData $carrotData;
    int label;

    CarrotServicepostCarrotData2(CarrotData carrotData, Continuation<? super CarrotServicepostCarrotData2> continuation) {
        super(2, continuation);
        this.$carrotData = carrotData;
    }

    @Override
    public final Continuation<Unit> create(Object obj, Continuation<?> continuation) {
        return new CarrotServicepostCarrotData2(this.$carrotData, continuation);
    }

    @Override
    public final Object invoke(CoroutineScope coroutineScope, Continuation<? super Unit> continuation) {
        return ((CarrotServicepostCarrotData2) create(coroutineScope, continuation)).invokeSuspend(Unit.INSTANCE);
    }

    @Override
    public final Object invokeSuspend(Object obj) {
        int carrotCounter;
        String str;
        Integer num;
        IntrinsicsKt.getCOROUTINE_SUSPENDED();
        switch (this.label) {
            case 0:
                ResultKt.throwOnFailure(obj);
                CarrotData $this$invokeSuspend_u24lambda_u240 = this.$carrotData;
                carrotCounter = CarrotService.INSTANCE.getCarrotCounter();
                $this$invokeSuspend_u24lambda_u240.setCarrotIndex(Boxing.boxInt(carrotCounter));
                $this$invokeSuspend_u24lambda_u240.setEpochTime(Boxing.boxLong(Instant.now().getEpochSecond()));
                $this$invokeSuspend_u24lambda_u240.setTimezone(TimeZone.getDefault().getID());
                try {
                    String json = JsonUtils.INSTANCE.toJsonString(this.$carrotData);
                    DatagramSocket datagramSocket = new DatagramSocket();
                    try {
                        DatagramSocket socket = datagramSocket;
                        socket.setSoTimeout(5000);
                        byte[] bytes = json.getBytes(Charsets.UTF_8);
                        Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                        int length = json.length();
                        str = CarrotService.ip;
                        num = CarrotService.port;
                        Intrinsics.checkNotNull(num);
                        socket.send(new DatagramPacket(bytes, length, new InetSocketAddress(str, num.intValue())));
                        Unit unit = Unit.INSTANCE;
                        CloseableKt.closeFinally(datagramSocket, null);
                    } finally {
                    }
                } catch (SocketTimeoutException e) {
                    Log.e("CarrotService", "postCarrotData: timeout", e);
                    ExtensionKt.push(LiveData.INSTANCE.getMainLog(), "postCarrotData: timeout " + e.getMessage());
                } catch (Exception e2) {
                    Log.e("CarrotService", "postCarrotData: error", e2);
                    ExtensionKt.push(LiveData.INSTANCE.getMainLog(), "postCarrotData: error " + e2.getMessage());
                }
                return Unit.INSTANCE;
            default:
                throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        }
    }
}
```

**File:** app/src/main/java/com/ajouatom/carrotman/dto/BroadcastData.java (L11-53)
```java
public final class BroadcastData {

    @JsonProperty("active")
    private final boolean active;
    private final boolean cameraState;

    @JsonProperty("Carrot2")
    private final String carrot2;
    private final boolean carrot2Active;

    @JsonProperty("CarrotRouteActive")
    private final boolean carrotRouteActive;

    @JsonProperty("ip")
    private final String ip;

    @JsonProperty("IsOnroad")
    private final boolean isOnRoad;

    @JsonProperty("log_carrot")
    private final String logCarrot;

    @JsonProperty("port")
    private final int port;
    private final long receiveTimestamp;

    @JsonProperty("sdi_dist")
    private final int sdiDist;

    @JsonProperty("tbt_dist")
    private final int tbtDist;

    @JsonProperty("trafficState")
    private final int trafficState;

    @JsonProperty("v_cruise_kph")
    private final int vCruiseKph;

    @JsonProperty("v_ego_kph")
    private final int vEgoKph;

    @JsonProperty("xState")
    private final int xState;
```

**File:** app/src/main/java/com/ajouatom/carrotman/dto/CarrotData.java (L8-146)
```java
public final class CarrotData {

    @JsonProperty("accuracy")
    private Float accuracy;

    @JsonInclude(JsonInclude.Include.NON_NULL)
    @JsonProperty("carrotArg")
    private String carrotArg;

    @JsonInclude(JsonInclude.Include.NON_NULL)
    @JsonProperty("carrotCmd")
    private String carrotCmd;

    @JsonProperty("carrotIndex")
    private Integer carrotIndex;

    @JsonProperty("epochTime")
    private Long epochTime;

    @JsonProperty("goalPosX")
    private Integer goalPosX;

    @JsonProperty("goalPosY")
    private Integer goalPosY;

    @JsonProperty("gps_speed")
    private Float gps_speed;

    @JsonProperty("heading")
    private Float heading;

    @JsonProperty("latitude")
    private Double latitude;

    @JsonProperty("longitude")
    private Double longitude;

    @JsonProperty("nGoPosDist")
    private Integer nGoPosDist;

    @JsonProperty("nGoPosTime")
    private Integer nGoPosTime;

    @JsonProperty("nLaneCount")
    private Integer nLaneCount;

    @JsonProperty("nPosAngle")
    private Integer nPosAngle;

    @JsonProperty("nPosSpeed")
    private Integer nPosSpeed;

    @JsonProperty("nRoadLimitSpeed")
    private Integer nRoadLimitSpeed;

    @JsonProperty("nSdiBlockDist")
    private Integer nSdiBlockDist;

    @JsonProperty("nSdiBlockSpeed")
    private Integer nSdiBlockSpeed;

    @JsonProperty("nSdiBlockType")
    private Integer nSdiBlockType;

    @JsonProperty("nSdiDist")
    private Integer nSdiDist;

    @JsonProperty("nSdiPlusBlockDist")
    private Integer nSdiPlusBlockDist;

    @JsonProperty("nSdiPlusBlockSpeed")
    private Integer nSdiPlusBlockSpeed;

    @JsonProperty("nSdiPlusBlockType")
    private Integer nSdiPlusBlockType;

    @JsonProperty("nSdiPlusDist")
    private Integer nSdiPlusDist;

    @JsonProperty("nSdiPlusSpeedLimit")
    private Integer nSdiPlusSpeedLimit;

    @JsonProperty("nSdiPlusType")
    private Integer nSdiPlusType;

    @JsonProperty("nSdiSection")
    private Integer nSdiSection;

    @JsonProperty("nSdiSpeedLimit")
    private Integer nSdiSpeedLimit;

    @JsonProperty("nSdiType")
    private Integer nSdiType;

    @JsonProperty("nTBTDist")
    private Integer nTBTDist;

    @JsonProperty("nTBTDistNext")
    private Integer nTBTDistNext;

    @JsonProperty("nTBTNextRoadWidth")
    private Integer nTBTNextRoadWidth;

    @JsonProperty("nTBTTurnType")
    private Integer nTBTTurnType;

    @JsonProperty("nTBTTurnTypeNext")
    private Integer nTBTTurnTypeNext;

    @JsonProperty("roadcate")
    private Integer roadcate;

    @JsonProperty("szFarDirName")
    private String szFarDirName;

    @JsonProperty("szGoalName")
    private String szGoalName;

    @JsonProperty("szNearDirName")
    private String szNearDirName;

    @JsonProperty("szPosRoadName")
    private String szPosRoadName;

    @JsonProperty("szTBTMainText")
    private String szTBTMainText;

    @JsonProperty("szTBTMainTextNext")
    private String szTBTMainTextNext;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("vpPosPointLat")
    private String vpPosPointLat;

    @JsonProperty("vpPosPointLon")
    private String vpPosPointLon;

```

**File:** app/src/main/java/com/ajouatom/carrotman/Detector.java (L40-77)
```java
public final class Detector {
    private static final float CONFIDENCE_THRESHOLD = 0.2f;
    private static final float INPUT_MEAN = 0.0f;
    private static final float INPUT_STANDARD_DEVIATION = 255.0f;
    private static final float IOU_THRESHOLD = 0.1f;
    private final Context context;
    private final DetectorListener detectorListener;
    private final ImageProcessor imageProcessor;
    private Interpreter interpreter;
    private final String labelPath;
    private List<String> labels;
    private final String modelPath;
    private int numChannel;
    private int numElements;
    private int tensorHeight;
    private int tensorWidth;
    private static final DataType INPUT_IMAGE_TYPE = DataType.FLOAT32;
    private static final DataType OUTPUT_IMAGE_TYPE = DataType.FLOAT32;

    @Metadata(d1 = {"\u0000\"\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010 \n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\t\n\u0002\b\u0002\bf\u0018\u00002\u00020\u0001J\u001e\u0010\u0002\u001a\u00020\u00032\f\u0010\u0004\u001a\b\u0012\u0004\u0012\u00020\u00060\u00052\u0006\u0010\u0007\u001a\u00020\bH&J\b\u0010\t\u001a\u00020\u0003H&¨\u0006\n"}, d2 = {"Lcom/ajouatom/carrotman/Detector$DetectorListener;", "", "onDetect", "", "boundingBoxes", "", "Lcom/ajouatom/carrotman/dto/BoundingBox;", "inferenceTime", "", "onEmptyDetect", "app_debug"}, k = 1, mv = {1, 9, 0}, xi = 48)
    public interface DetectorListener {
        void onDetect(List<BoundingBox> boundingBoxes, long inferenceTime);

        void onEmptyDetect();
    }

    public Detector(Context context, String modelPath, String labelPath, DetectorListener detectorListener) {
        Intrinsics.checkNotNullParameter(context, "context");
        Intrinsics.checkNotNullParameter(modelPath, "modelPath");
        Intrinsics.checkNotNullParameter(labelPath, "labelPath");
        Intrinsics.checkNotNullParameter(detectorListener, "detectorListener");
        this.context = context;
        this.modelPath = modelPath;
        this.labelPath = labelPath;
        this.detectorListener = detectorListener;
        this.labels = new ArrayList();
        this.imageProcessor = new ImageProcessor.Builder().add((TensorOperator) new NormalizeOp(0.0f, INPUT_STANDARD_DEVIATION)).add((TensorOperator) new CastOp(INPUT_IMAGE_TYPE)).build();
    }
```

**File:** app/src/main/java/com/ajouatom/carrotman/MainActivity.java (L86-116)
```java
public final class MainActivity extends AppCompatActivity implements Detector.DetectorListener {
    private ActivityMainBinding binding;
    private boolean bound;
    private Camera camera;
    private ExecutorService cameraExecutor;
    private ProcessCameraProvider cameraProvider;
    private Detector detector;
    private boolean dispLogAll;
    private GestureDetectorCompat gestureDetector;
    private ImageAnalysis imageAnalyzer;
    private final boolean isFrontCamera;
    private boolean isListening;
    private boolean pendingScan;
    private Preview preview;
    private int sdiCount;
    private SpeechRecognizer speechRecognizer;
    private boolean startCameraDetect;
    private boolean startListening;
    private final int RECORD_REQUEST_CODE = TypedValues.TYPE_TARGET;
    private final CoroutineScope ioScope = CoroutineScopeKt.CoroutineScope(Dispatchers.getIO());
    private int cropWidth = 1;
    private int cropHeight = 1;
    private int startX = 1;
    private int startY = 1;
    private int imgWidth = 1;
    private int imgHeight = 1;
    private final String[] permissions = {"android.permission.CAMERA", "android.permission.RECORD_AUDIO", "android.permission.REQUEST_INSTALL_PACKAGES", "android.permission.BLUETOOTH_SCAN", "android.permission.BLUETOOTH_CONNECT", "android.permission.ACCESS_FINE_LOCATION"};

    public final boolean getIsListening() {
        return this.isListening;
    }
```

**File:** app/src/main/java/com/ajouatom/carrotman/service/HudService.java (L29-82)
```java
public final class HudService extends Service {
    private static boolean isRunning;
    private static final SparseIntArray sdiMap;
    private static final SparseIntArray tbtTurnTypeMap;
    private BLEManager bleManager;
    private int bleRetryCount;
    private final Handler bleRetryHandler;
    private final long bleRetryInterval;
    private boolean bleRetrying;
    private int ble_safeCounter;
    private BroadcastData broadcastData;
    private final Observer<BroadcastData> carrotBroadcastObserver;
    private int counter;
    private boolean first_connect;
    private int image_mode;
    private OpakrRgdata opakrRgdata;
    private final Observer<OpakrRgdata> opakrRgdataObserver;
    private final HudService$retryRunnable$1 retryRunnable;
    private int sdiCount;
    private boolean sent_active_cruise;
    private long sent_currentTimeSec;
    private int sent_nGoPosDist;
    private int sent_nGoPosTime;
    private int sent_nSdiDist;
    private int sent_nSdiSpeedLimit;
    private int sent_nSdiType;
    private int sent_nTBTDist;
    private int sent_nTBTDistNext;
    private int sent_nTBTTurnType;
    private int sent_nTBTTurnTypeNext;
    private int sent_overSpeed;
    private boolean sent_rearCamera;
    private String sent_szPosRoadName;
    private String sent_szTBTMainText;
    private int sent_vEgo;
    private int sent_v_cruise_kph;
    private PowerManager.WakeLock wakeLock;

    public HudService() {
        Log.d("HudService", "init");
        this.carrotBroadcastObserver = new Observer() {
            @Override
            public final void onChanged(Object obj) {
                HudService.carrotBroadcastObserver$lambda$1(HudService.this, (BroadcastData) obj);
            }
        };
        this.opakrRgdataObserver = new Observer() {
            @Override
            public final void onChanged(Object obj) {
                HudService.opakrRgdataObserver$lambda$3(HudService.this, (OpakrRgdata) obj);
            }
        };
        this.bleRetryHandler = new Handler(Looper.getMainLooper());
        this.bleRetryInterval = 10000L;
```

**File:** app/src/main/java/com/ajouatom/carrotman/service/UpdateService.java (L30-46)
```java
public final class UpdateService {
    public static final UpdateService INSTANCE = new UpdateService();
    private static final int REQUEST_CODE_INSTALL_PERMISSION = 110;
    private static final String UPDATE_INFO_URL = "http://shind0.synology.me/carrotman/carrot.json";

    private UpdateService() {
    }

    public final void addLog(String message) {
        ExtensionKt.push(LiveData.INSTANCE.getMainLog(), message);
    }

    public final void checkForUpdates(final Context context) {
        Intrinsics.checkNotNullParameter(context, "context");
        final long currentVersionCode = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).getLongVersionCode();
        addLog("CarrotMan version {" + currentVersionCode + '}');
        OkHttpClient client = new OkHttpClient();
```

**File:** app/src/main/AndroidManifest.xml (L1-30)
```text
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="34" android:compileSdkVersionCodename="14" platformBuildVersionCode="34" platformBuildVersionName="14">  <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
  <uses-feature android:name="android.hardware.camera" />
  <uses-permission android:name="android.permission.CAMERA" />
  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
  <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.RECORD_AUDIO" />
  <uses-permission android:name="android.permission.REORDER_TASKS" />
  <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
  <uses-permission android:name="android.permission.BLUETOOTH" />
  <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
  <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
  <uses-permission android:name="android.permission.WAKE_LOCK" />
  <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
  <permission android:name="com.ajouatom.carrotman.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" android:protectionLevel="signature" />
  <uses-permission android:name="com.ajouatom.carrotman.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.READ_PHONE_STATE" />
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
  <application android:usesCleartextTraffic="true" android:allowBackup="false" android:appComponentFactory="androidx.core.app.CoreComponentFactory" android:dataExtractionRules="@xml/data_extraction_rules" android:debuggable="false" android:fullBackupContent="@xml/backup_rules" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:name="com.ajouatom.carrotman.MyApp" android:networkSecurityConfig="@xml/network_security_config" android:requestLegacyExternalStorage="true" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/Theme.CarrotMan">
    <provider android:authorities="com.ajouatom.carrotman.provider" android:exported="true" android:grantUriPermissions="true" android:name="com.ajouatom.carrotman.event.provider.TMapEventProvider" />
    <provider android:authorities="com.ajouatom.carrotman.fileprovider" android:exported="false" android:grantUriPermissions="true" android:name="androidx.core.content.FileProvider">
      <meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" android:value="" />
    </provider>
    <service android:enabled="true" android:exported="true" android:foregroundServiceType="connectedDevice" android:name="com.ajouatom.carrotman.service.HudService" />
```

**File:** app/src/main/java/com/ajouatom/carrotman/service/CarrotServicesendVertx1.java (L27-44)
```java
final class CarrotServicesendVertx1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object> {
    int label;

    CarrotServicesendVertx1(Continuation<? super CarrotServicesendVertx1> continuation) {
        super(2, continuation);
    }

    @Override
    public final Continuation<Unit> create(Object obj, Continuation<?> continuation) {
        return new CarrotServicesendVertx1(continuation);
    }

    @Override
    public final Object invoke(CoroutineScope coroutineScope, Continuation<? super Unit> continuation) {
        return ((CarrotServicesendVertx1) create(coroutineScope, continuation)).invokeSuspend(Unit.INSTANCE);
    }

    @Metadata(d1 = {"\u0000\n\n\u0000\n\u0002\u0010\u0002\n\u0002\u0018\u0002\u0010\u0000\u001a\u00020\u0001*\u00020\u0002H\u008a@"}, d2 = {"<anonymous>", "", "Lkotlinx/coroutines/CoroutineScope;"}, k = 3, mv = {1, 9, 0}, xi = 48)
```

**File:** app/src/main/java/com/ajouatom/carrotman/extension/ExtensionKt.java (L16-46)
```java
public final class ExtensionKt {
    public static String toMessage$default(DatagramPacket datagramPacket, Charset charset, int i, Object obj) {
        if ((i & 1) != 0) {
            charset = Charsets.UTF_8;
        }
        return toMessage(datagramPacket, charset);
    }

    public static final String toMessage(DatagramPacket $this$toMessage, Charset charset) {
        Intrinsics.checkNotNullParameter($this$toMessage, "<this>");
        Intrinsics.checkNotNullParameter(charset, "charset");
        byte[] data = $this$toMessage.getData();
        Intrinsics.checkNotNullExpressionValue(data, "getData(...)");
        return new String(data, 0, $this$toMessage.getLength(), charset);
    }

    public static final <E> void push(LinkedBlockingQueue<E> linkedBlockingQueue, E e) {
        Intrinsics.checkNotNullParameter(linkedBlockingQueue, "<this>");
        while (!linkedBlockingQueue.offer(e)) {
            linkedBlockingQueue.poll();
        }
    }

    public static final int getColorResCompat(Context $this$getColorResCompat, int id) {
        Intrinsics.checkNotNullParameter($this$getColorResCompat, "<this>");
        TypedValue resolvedAttr = new TypedValue();
        $this$getColorResCompat.getTheme().resolveAttribute(id, resolvedAttr, true);
        int colorRes = resolvedAttr.resourceId != 0 ? resolvedAttr.resourceId : resolvedAttr.data;
        return ContextCompat.getColor($this$getColorResCompat, colorRes);
    }
}
```

**File:** app/src/main/java/com/ajouatom/carrotman/event/LiveData.java (L32-56)
```java
public final class LiveData {
    public static final LiveData INSTANCE = new LiveData();
    private static final LinkedBlockingQueue<String> mainLog = new LinkedBlockingQueue<>(4096);
    private static final DistinctLiveData<Boolean> carrotDeviceConnected = new DistinctLiveData<>();
    private static final DistinctLiveData<String> carrotIpAddress = new DistinctLiveData<>();
    private static final DistinctLiveData<BroadcastData> carrotBroadcastData = new DistinctLiveData<>();
    private static final DistinctLiveData<SshKeypair> sshKeypair = new DistinctLiveData<>(new SshKeypair(null, null, null, 7, null));
    private static final MutableLiveData<CarrotCommand> carrotCommand = new MutableLiveData<>();
    private static final MutableLiveData<Boolean> cameraStart = new MutableLiveData<>();
    private static final MutableLiveData<Boolean> voiceStart = new MutableLiveData<>();
    private static final DistinctLiveData<Boolean> enableCamera = new DistinctLiveData<>(Boolean.valueOf(PreferenceUtils.getBoolean$default(PreferenceUtils.INSTANCE, "is_checkCameraStart", false, 2, null)));
    private static final DistinctLiveData<Boolean> enableVoice = new DistinctLiveData<>(Boolean.valueOf(PreferenceUtils.getBoolean$default(PreferenceUtils.INSTANCE, "is_checkVoiceStart", false, 2, null)));
    private static final DistinctLiveData<Boolean> enableDestination = new DistinctLiveData<>(Boolean.valueOf(PreferenceUtils.getBoolean$default(PreferenceUtils.INSTANCE, "is_sendDestination", false, 2, null)));
    private static final DistinctLiveData<Boolean> enableRoute = new DistinctLiveData<>(Boolean.valueOf(PreferenceUtils.getBoolean$default(PreferenceUtils.INSTANCE, "is_sendRouteInfo", false, 2, null)));
    private static final MutableLiveData<OpakrSinf> opakrSinf = new MutableLiveData<>();
    private static final MutableLiveData<OpakrRoute> opakrRoute = new MutableLiveData<>();
    private static final MutableLiveData<List<OpakrVertex>> opakrVrtx = new MutableLiveData<>();
    private static final MutableLiveData<OpakrRgdata> opakrRgdata = new MutableLiveData<>();

    private LiveData() {
    }

    static {
        Log.d("LiveData", "init");
        BuildersKt__Builders_commonKt.launch$default(CoroutineScopeKt.CoroutineScope(Dispatchers.getMain()), null, null, new fun1(null), 3, null);
```

**File:** app/src/main/java/zmq/Options.java (L19-86)
```java
public class Options {
    public static final int CURVE_KEYSIZE = 32;
    public static final int CURVE_KEYSIZE_Z85 = 40;
    public int sendHwm = 1000;
    public int recvHwm = 1000;
    public long affinity = 0;
    public short identitySize = (short) ZMQ.DEFAULT_IDENTITY.length;
    public byte[] identity = ZMQ.DEFAULT_IDENTITY;
    int rate = 100;
    int recoveryIvl = ZMQ.DEFAULT_RECOVERY_IVL;
    int multicastHops = 1;
    public int sndbuf = 0;
    public int rcvbuf = 0;
    public int tos = 0;
    public int type = -1;
    public int linger = -1;
    public int reconnectIvl = 100;
    public int reconnectIvlMax = 0;
    public int backlog = 100;
    public long maxMsgSize = -1;
    int recvTimeout = -1;
    int sendTimeout = -1;
    public boolean ipv6 = ZMQ.DEFAULT_IPV6;
    public boolean immediate = true;
    public String socksProxyAddress = ZMQ.DEFAULT_SOCKS_PROXY_ADDRESS;
    public int tcpKeepAlive = -1;
    public int tcpKeepAliveCnt = -1;
    public int tcpKeepAliveIdle = -1;
    public int tcpKeepAliveIntvl = -1;
    public Mechanisms mechanism = ZMQ.DEFAULT_MECHANISM;
    public boolean asServer = false;
    public String zapDomain = "";
    public String plainUsername = null;
    public String plainPassword = null;
    public byte[] curvePublicKey = new byte[32];
    public byte[] curveSecretKey = new byte[32];
    public byte[] curveServerKey = new byte[32];
    String gssPrincipal = null;
    String gssServicePrincipal = null;
    boolean gssPlaintext = false;
    public boolean conflate = false;
    public int handshakeIvl = ZMQ.DEFAULT_HANDSHAKE_IVL;
    public int heartbeatTtl = 0;
    public int heartbeatInterval = 0;
    public int heartbeatTimeout = -1;
    public byte[] heartbeatContext = ZMQ.DEFAULT_HEARTBEAT_CONTEXT;
    public MsgAllocator allocator = ZMQ.DEFAULT_MSG_ALLOCATOR;
    public SelectorProviderChooser selectorChooser = ZMQ.DEFAULT_SELECTOR_CHOOSER;
    public Msg helloMsg = ZMQ.DEFAULT_HELLO_MSG;
    public boolean canSendHelloMsg = false;
    public Msg disconnectMsg = ZMQ.DEFAULT_DISCONNECT_MSG;
    public boolean canReceiveDisconnectMsg = false;
    public Msg hiccupMsg = ZMQ.DEFAULT_HICCUP_MSG;
    public boolean canReceiveHiccupMsg = false;
    public int asType = -1;
    public String selfAddressPropertyName = ZMQ.DEFAULT_SELF_ADDRESS_PROPERTY_NAME;
    String lastEndpoint = null;
    public final Errno errno = new Errno();
    public final List<TcpAddress.TcpAddressMask> tcpAcceptFilters = new ArrayList();
    final List<IpcAddress.IpcAddressMask> ipcAcceptFilters = new ArrayList();
    public int peerLastRoutingId = 0;
    public int socketId = 0;
    public boolean filter = false;
    public boolean recvIdentity = false;
    public boolean rawSocket = false;
    public Class<? extends IDecoder> decoder = null;
    public Class<? extends IEncoder> encoder = null;

```
